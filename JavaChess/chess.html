<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: clamp(300px, 90vw, 600px);
            height: clamp(300px, 90vw, 600px);
            border: 2px solid #374151; /* gray-700 */
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transition: transform 0.5s ease-in-out;
        }
        /* Style for flipping the board */
        .board.flipped {
            transform: rotate(180deg);
        }
        /* Un-flips the pieces so they are upright */
        .board.flipped .square {
            transform: rotate(180deg);
        }
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(24px, 7vw, 48px);
            user-select: none;
            position: relative;
        }
        .light { background-color: #F3F4F6; } /* gray-100 */
        .dark { background-color: #60A5FA; } /* blue-400 */
        .piece {
            cursor: grab;
            width: 90%;
            height: 90%;
            object-fit: contain;
        }
        .piece.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        .valid-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30%;
            height: 30%;
            background-color: rgba(4, 120, 87, 0.5); /* emerald-700 with opacity */
            border-radius: 50%;
        }
        .promotion-choice {
            transition: transform 0.2s;
        }
        .promotion-choice:hover {
            transform: scale(1.1);
            background-color: rgba(96, 165, 250, 0.3); /* blue-400 with opacity */
        }
        .timer {
            transition: background-color 0.3s, color 0.3s;
        }
        .timer.active {
            background-color: #10B981; /* emerald-500 */
            color: white;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto flex flex-col items-center">
        <h1 class="text-4xl font-bold mb-2 text-blue-400">Chess</h1>
        <p class="text-gray-400 mb-6">Create or join a game to play real-time multiplayer chess.</p>
        
        <!-- Multiplayer UI -->
        <div id="lobby" class="w-full max-w-2xl bg-gray-800 p-4 rounded-lg shadow-lg mb-4 text-center">
            <h2 class="text-2xl font-bold mb-4">Multiplayer</h2>
            <div class="mb-4">
                <label class="font-semibold">Time Control:</label>
                <select id="timeControlMinutes" class="bg-gray-700 rounded p-1 mx-2">
                    <option value="1">1 min</option>
                    <option value="3" selected>3 min</option>
                    <option value="5">5 min</option>
                    <option value="10">10 min</option>
                </select>
                <label>+ </label>
                <select id="timeControlIncrement" class="bg-gray-700 rounded p-1 mx-2">
                    <option value="0">0 sec</option>
                    <option value="1">1 sec</option>
                    <option value="2" selected>2 sec</option>
                    <option value="5">5 sec</option>
                </select>
                <label>increment</label>
            </div>
            <div class="flex flex-col sm:flex-row gap-4">
                 <button id="createGameBtn" class="bg-emerald-600 hover:bg-emerald-700 text-white font-semibold py-2 px-4 rounded-md transition duration-200 shadow-md flex-1 disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>Create New Game</button>
                 <div class="flex flex-1">
                    <input type="text" id="gameIdInput" placeholder="Enter Game ID to Join..." class="flex-grow bg-gray-700 text-white border border-gray-600 rounded-l-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-600" disabled>
                    <button id="joinGameBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-r-md transition duration-200 shadow-md disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>Join Game</button>
                 </div>
            </div>
        </div>

        <!-- Game Info Display -->
        <div id="gameInfo" class="w-full max-w-2xl bg-gray-800 p-4 rounded-lg shadow-lg mb-4 text-center text-lg hidden">
             <p>Game ID: <code id="gameIdDisplay" class="bg-gray-700 text-emerald-400 rounded px-2 py-1 cursor-pointer" title="Click to copy"></code></p>
             <p>You are Player: <span id="playerColorDisplay" class="font-bold"></span></p>
             <p>Your User ID: <span id="userIdDisplay" class="font-mono text-xs text-gray-400"></span></p>
             <p>App ID: <span id="appIdDisplay" class="font-mono text-xs text-gray-400"></span></p>
        </div>

        <!-- Timers -->
        <div id="timers" class="w-full max-w-2xl flex justify-between mb-2 text-2xl font-mono hidden">
            <div id="timer-b" class="timer bg-gray-800 p-2 rounded-md shadow-lg">Black: <span id="time-b">00:00</span></div>
            <div id="timer-w" class="timer bg-gray-800 p-2 rounded-md shadow-lg">White: <span id="time-w">00:00</span></div>
        </div>

        <div id="board" class="board mb-6"></div>

        <div class="w-full max-w-2xl bg-gray-800 p-4 rounded-lg shadow-lg">
            <div class="flex flex-col sm:flex-row gap-4">
                <input type="text" id="fenInput" class="flex-grow bg-gray-700 text-white border border-gray-600 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="FEN will appear here...">
                <button id="copyFen" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-md transition duration-200 shadow-md">Copy FEN</button>
            </div>
            <div id="status" class="mt-3 text-center text-lg font-medium text-gray-300 h-6">Authenticating...</div>
        </div>
    </div>

    <!-- Promotion Modal -->
    <div id="promotionModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl text-center border border-gray-600">
            <h3 class="text-2xl font-bold mb-5 text-white">Promote Pawn to:</h3>
            <div id="promotionChoices" class="flex gap-4"></div>
        </div>
    </div>

    <!-- End Game Modal -->
    <div id="endGameModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl text-center border border-gray-600">
            <h3 id="endGameResultText" class="text-3xl font-bold mb-4 text-white"></h3>
            <p id="endGameReasonText" class="text-lg text-gray-300 mb-6"></p>
            <button id="playAgainBtn" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded">Play Again</button>
        </div>
    </div>

    <!-- Notification Element -->
    <div id="notification" class="hidden fixed top-5 right-5 bg-red-600 text-white py-2 px-4 rounded-lg shadow-lg transition-transform transform translate-x-full duration-300">
    </div>


    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // User provided config as a fallback
        const userFirebaseConfig = {
          apiKey: "AIzaSyC1jSVCphzXFHep2YkzvQdtHwEJfnvo_Ck",
          authDomain: "chess-445d9.firebaseapp.com",
          projectId: "chess-445d9",
          storageBucket: "chess-445d9.firebasestorage.app",
          messagingSenderId: "341237381228",
          appId: "1:341237381228:web:a1a17cefe1648ec63ec049",
          measurementId: "G-H9T64FEG93"
        };
        
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : userFirebaseConfig;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Firebase Initialization
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // --- DOM Elements ---
        const boardElement = document.getElementById('board');
        const fenInputElement = document.getElementById('fenInput');
        const statusElement = document.getElementById('status');
        const createGameBtn = document.getElementById('createGameBtn');
        const joinGameBtn = document.getElementById('joinGameBtn');
        const gameIdInput = document.getElementById('gameIdInput');
        const gameInfoDiv = document.getElementById('gameInfo');
        const gameIdDisplay = document.getElementById('gameIdDisplay');
        const playerColorDisplay = document.getElementById('playerColorDisplay');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const appIdDisplay = document.getElementById('appIdDisplay');
        const copyFenBtn = document.getElementById('copyFen');
        const endGameModal = document.getElementById('endGameModal');
        const endGameResultText = document.getElementById('endGameResultText');
        const endGameReasonText = document.getElementById('endGameReasonText');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const timeControlMinutesSelect = document.getElementById('timeControlMinutes');
        const timeControlIncrementSelect = document.getElementById('timeControlIncrement');
        const timersDiv = document.getElementById('timers');
        const timeWDisplay = document.getElementById('time-w');
        const timeBDisplay = document.getElementById('time-b');
        
        // --- Game State ---
        const initialFen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
        let boardState = [];
        let sourceSquare = null;
        let currentPlayer = 'w';
        let castlingRights = 'KQkq';
        let enPassantTarget = '-';
        let promotionMoveInfo = null;
        let isGameOver = false;

        // --- Timer State ---
        let timerInterval = null;
        let localTimeW = 0;
        let localTimeB = 0;
        let timerSettings = null;

        // --- Dragging State (Replaces native DnD) ---
        let isDragging = false;
        let clonedPiece = null;
        let originalPiece = null;

        // --- Multiplayer State ---
        let userId = null;
        let currentGameId = null;
        let playerColor = null;
        let gameUnsubscribe = null;
        let areTwoPlayers = false;

        const imageBaseUrl = 'https://raw.githubusercontent.com/ZefferyH/Chess/main/chess_set_3/';
        const pieceImageMap = {
            'p': 'bP.png', 'r': 'bR.png', 'n': 'bN.png', 'b': 'bB.png', 'q': 'bQ.png', 'k': 'bK.png',
            'P': 'wP.png', 'R': 'wR.png', 'N': 'wN.png', 'B': 'wB.png', 'Q': 'wQ.png', 'K': 'wK.png'
        };

        // --- UI Functions ---
        function showNotification(message, isError = true) {
            const notificationElement = document.getElementById('notification');
            notificationElement.textContent = message;
            notificationElement.classList.toggle('bg-red-600', isError);
            notificationElement.classList.toggle('bg-emerald-600', !isError);
            notificationElement.classList.remove('hidden', 'translate-x-full');

            setTimeout(() => {
                notificationElement.classList.add('-translate-x-0');
            }, 10);
        
            setTimeout(() => {
                notificationElement.classList.add('translate-x-full');
                setTimeout(() => notificationElement.classList.add('hidden'), 300);
            }, 3000);
        }

        function copyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            textArea.style.padding = 0;
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            textArea.style.background = 'transparent';
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showNotification('Copied to clipboard!', false);
                } else {
                    showNotification('Failed to copy.');
                }
            } catch (err) {
                console.error('Failed to copy: ', err);
                showNotification('Failed to copy.');
            }
            document.body.removeChild(textArea);
        }


        // --- Authentication ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                userIdDisplay.textContent = userId;
                console.log("Authenticated with user ID:", userId);
                
                // Enable UI now that authentication is complete
                createGameBtn.disabled = false;
                joinGameBtn.disabled = false;
                gameIdInput.disabled = false;
                updateStatus(); // Ensure status is updated after successful authentication
            } else {
                userId = null;
                createGameBtn.disabled = true;
                joinGameBtn.disabled = true;
                gameIdInput.disabled = true;
                statusElement.textContent = "Authentication failed. Please refresh.";
            }
        });

        async function signIn() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication failed:", error);
                statusElement.textContent = "Error: Could not connect to server.";
            }
        }

        // --- Core Game Logic (Multiplayer Adapted) ---
        
        function createBoard() {
            boardElement.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.classList.add('square', (row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;
                    boardElement.appendChild(square);
                }
            }
        }
        
        async function createGame() {
            if (!userId) {
                showNotification("You must be authenticated to create a game.");
                return;
            }
            const minutes = parseInt(timeControlMinutesSelect.value);
            const increment = parseInt(timeControlIncrementSelect.value);
            const timeInMillis = minutes * 60 * 1000;

            const newGameId = Math.random().toString(36).substring(2, 8).toUpperCase();
            const gameRef = doc(db, `/artifacts/${appId}/public/data/games`, newGameId);
            
            await setDoc(gameRef, {
                fen: initialFen,
                playerW: userId,
                playerB: null,
                createdAt: serverTimestamp(),
                timeControl: { minutes, increment },
                timeW: timeInMillis,
                timeB: timeInMillis,
                lastMoveTimestamp: serverTimestamp(),
                rematch: { w: false, b: false }
            });
            
            joinGame(newGameId);
        }

        async function joinGame(gameId) {
            if (!userId) {
                showNotification("You must be authenticated to join a game.");
                return;
            }
            if (!gameId) {
                showNotification("Please enter a Game ID.");
                return;
            }
            if (gameUnsubscribe) gameUnsubscribe(); // Unsubscribe from previous game

            const gameRef = doc(db, `/artifacts/${appId}/public/data/games`, gameId);
            let gameDoc = await getDoc(gameRef);

            if (!gameDoc.exists()) {
                showNotification("Game not found!");
                return;
            }

            let gameData = gameDoc.data();
            
            if (!gameData.playerB && gameData.playerW !== userId) {
                try {
                    await updateDoc(gameRef, { 
                        playerB: userId,
                        lastMoveTimestamp: serverTimestamp() 
                    });
                    gameDoc = await getDoc(gameRef);
                    gameData = gameDoc.data();
                } catch (e) {
                    console.error("Error joining game: ", e);
                    showNotification("Could not join the game.");
                    return;
                }
            }

            if (gameData.playerW === userId) {
                playerColor = 'w';
            } else if (gameData.playerB === userId) {
                playerColor = 'b';
            } else {
                showNotification("Game is full!");
                return;
            }

            if (playerColor === 'b') {
                boardElement.classList.add('flipped');
            } else {
                boardElement.classList.remove('flipped');
            }
            
            currentGameId = gameId;
            gameIdDisplay.textContent = currentGameId;
            appIdDisplay.textContent = appId;
            playerColorDisplay.textContent = playerColor === 'w' ? 'White' : 'Black';
            gameInfoDiv.classList.remove('hidden');
            lobby.classList.add('hidden');
            timersDiv.classList.remove('hidden');

            gameUnsubscribe = onSnapshot(gameRef, async (doc) => {
                const gameData = doc.data();
                if (!gameData) return;

                areTwoPlayers = !!(gameData.playerW && gameData.playerB);

                // Handle Rematch Logic
                const rematchState = gameData.rematch || { w: false, b: false };

                // If both players want a rematch, reset the game.
                // Only player W sends the update to prevent a race condition.
                if (rematchState.w && rematchState.b && playerColor === 'w') {
                    const timeInMillis = gameData.timeControl.minutes * 60 * 1000;
                    await updateDoc(doc.ref, {
                        fen: initialFen,
                        winner: null, 
                        reason: null,
                        playerW: gameData.playerB, // Swap players
                        playerB: gameData.playerW,
                        timeW: timeInMillis,
                        timeB: timeInMillis,
                        lastMoveTimestamp: serverTimestamp(),
                        rematch: { w: false, b: false } // Reset the rematch state
                    });
                    return; // The listener will fire again with the new state
                }


                let newPlayerColor = null;
                if(gameData.playerW === userId) newPlayerColor = 'w';
                if(gameData.playerB === userId) newPlayerColor = 'b';
                
                if (newPlayerColor && newPlayerColor !== playerColor) {
                    playerColor = newPlayerColor;
                    playerColorDisplay.textContent = playerColor === 'w' ? 'White' : 'Black';
                    if (playerColor === 'b') {
                        boardElement.classList.add('flipped');
                    } else {
                        boardElement.classList.remove('flipped');
                    }
                }

                if (gameData.winner) {
                    isGameOver = true;
                    stopTimer();
                    let result, reason;
                    if (gameData.winner === 'draw') {
                        result = 'Draw';
                        reason = gameData.reason || 'Stalemate';
                    } else {
                        const winnerName = gameData.winner === 'w' ? 'White' : 'Black';
                        result = `${winnerName} Wins!`;
                        reason = gameData.reason || 'Checkmate';
                    }
                    showEndGameModal(result, reason);
                    
                    // Update the Play Again button based on rematch status
                    const myColor = playerColor;
                    const opponentColor = playerColor === 'w' ? 'b' : 'w';

                    if (rematchState[myColor]) {
                        playAgainBtn.disabled = true;
                        playAgainBtn.textContent = "Waiting for Opponent...";
                    } else if (rematchState[opponentColor]) {
                        playAgainBtn.disabled = false;
                        playAgainBtn.textContent = "Opponent wants a Rematch!";
                    }

                } else {
                    isGameOver = false;
                    endGameModal.classList.add('hidden');
                }
                
                // Timer sync
                timerSettings = gameData.timeControl;
                updateTimers(gameData);

                const fen = gameData.fen;
                if (fen && fenInputElement.value !== fen) {
                    parseFen(fen);
                }
            });
        }
        
        function renderBoard() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                square.innerHTML = '';
                square.classList.remove('valid-move');
            });

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece) {
                        const square = boardElement.querySelector(`[data-row='${row}'][data-col='${col}']`);
                        const pieceElement = document.createElement('img');
                        pieceElement.classList.add('piece');
                        pieceElement.src = imageBaseUrl + pieceImageMap[piece.type];
                        pieceElement.draggable = true;
                        pieceElement.dataset.piece = piece.type;
                        pieceElement.dataset.color = piece.color;
                        square.appendChild(pieceElement);
                    }
                }
            }
            updateStatus();
        }

        function parseFen(fen) {
            boardState = Array(8).fill(null).map(() => Array(8).fill(null));
            const [placement, turn, castling, enPassant] = fen.split(' ');
            
            currentPlayer = turn;
            castlingRights = castling || '-';
            enPassantTarget = enPassant || '-';

            let row = 0, col = 0;
            for (const char of placement) {
                if (char === '/') {
                    row++;
                    col = 0;
                } else if (isNaN(parseInt(char))) {
                    boardState[row][col] = {
                        type: char,
                        color: char.toLowerCase() === char ? 'b' : 'w',
                    };
                    col++;
                } else {
                    col += parseInt(char);
                }
            }
            fenInputElement.value = fen;
            renderBoard();
        }

        function generateFen() {
            let fen = '';
            for (let row = 0; row < 8; row++) {
                let empty = 0;
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece) {
                        if (empty > 0) {
                            fen += empty;
                            empty = 0;
                        }
                        fen += piece.type;
                    } else {
                        empty++;
                    }
                }
                if (empty > 0) fen += empty;
                if (row < 7) fen += '/';
            }
            fen += ` ${currentPlayer} ${castlingRights} ${enPassantTarget} 0 1`;
            return fen;
        }

        function updateStatus() {
            if (!areTwoPlayers && !isGameOver) {
                statusElement.textContent = "Waiting for opponent to join...";
                return;
            }
            const turn = currentPlayer === 'w' ? 'White' : 'Black';
            let statusText = `${turn}'s turn to move`;
            if (playerColor && currentPlayer !== playerColor) {
                statusText = `Waiting for ${turn}...`;
            }
            if (isKingInCheck(currentPlayer, boardState)) {
                 statusText += ` - Check!`;
            }
            statusElement.textContent = statusText;
        }

        // --- Custom Drag and Drop Implementation ---

        function onDragStart(e) {
            if (e.button !== 0 || isGameOver) return; // Only handle left clicks and active games

            const piece = e.target.closest('.piece');
            if (!piece) return;

            if (piece.dataset.color !== currentPlayer || currentPlayer !== playerColor) {
                return;
            }

            e.preventDefault();

            originalPiece = piece;
            sourceSquare = piece.parentElement;
            showValidMoves(sourceSquare);

            clonedPiece = piece.cloneNode(true);
            clonedPiece.style.position = 'absolute';
            clonedPiece.style.zIndex = '1000';
            clonedPiece.style.pointerEvents = 'none';
            
            clonedPiece.style.width = `${piece.offsetWidth}px`;
            clonedPiece.style.height = `${piece.offsetHeight}px`;

            clonedPiece.classList.add('dragging');
            document.body.appendChild(clonedPiece);

            originalPiece.style.visibility = 'hidden';

            moveClonedPiece(e.pageX, e.pageY);

            isDragging = true;
            
            document.addEventListener('mousemove', onDragging);
            document.addEventListener('mouseup', onDragEnd, { once: true });
        }

        function moveClonedPiece(pageX, pageY) {
            if (!clonedPiece) return;
            clonedPiece.style.left = `${pageX - clonedPiece.offsetWidth / 2}px`;
            clonedPiece.style.top = `${pageY - clonedPiece.offsetHeight / 2}px`;
        }

        function onDragging(e) {
            if (!isDragging) return;
            moveClonedPiece(e.pageX, e.pageY);
        }

        function onDragEnd(e) {
            if (!isDragging) return;

            isDragging = false;
            document.removeEventListener('mousemove', onDragging);

            if(clonedPiece) clonedPiece.style.display = 'none';
            const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
            if(clonedPiece) clonedPiece.style.display = '';

            const targetSquare = elementUnderCursor ? elementUnderCursor.closest('.square') : null;

            if (targetSquare && sourceSquare) {
                const fromRow = parseInt(sourceSquare.dataset.row);
                const fromCol = parseInt(sourceSquare.dataset.col);
                const toRow = parseInt(targetSquare.dataset.row);
                const toCol = parseInt(targetSquare.dataset.col);

                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                    handleMove(fromRow, fromCol, toRow, toCol);
                }
            }

            if(clonedPiece && clonedPiece.parentNode) document.body.removeChild(clonedPiece);
            if(originalPiece) originalPiece.style.visibility = 'visible';
            
            clonedPiece = null;
            originalPiece = null;
            sourceSquare = null;
            clearValidMoves();
        }

        function handleMove(fromRow, fromCol, toRow, toCol) {
            const piece = boardState[fromRow][fromCol];
            if (piece.type.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
                promotionMoveInfo = { fromRow, fromCol, toRow, toCol };
                showPromotionModal(piece.color);
            } else {
                performMove(fromRow, fromCol, toRow, toCol);
            }
        }

        async function performMove(fromRow, fromCol, toRow, toCol, promotionPiece = null) {
            stopTimer(); // Stop timer as soon as move is initiated
            let piece = { ...boardState[fromRow][fromCol] };
            let newEnPassantTarget = '-';

            if (piece.type.toLowerCase() === 'p' && enPassantTarget !== '-') {
                const targetCol = enPassantTarget.charCodeAt(0) - 'a'.charCodeAt(0);
                const targetRow = 8 - parseInt(enPassantTarget[1]);
                if (toRow === targetRow && toCol === targetCol && !boardState[toRow][toCol]) {
                    boardState[fromRow][toCol] = null;
                }
            }
            
            if (promotionPiece) piece.type = promotionPiece;

            if (piece.type.toLowerCase() === 'k' && Math.abs(fromCol - toCol) === 2) {
                const rookFromCol = toCol > fromCol ? 7 : 0;
                const rookToCol = toCol > fromCol ? 5 : 3;
                boardState[fromRow][rookToCol] = boardState[fromRow][rookFromCol];
                boardState[fromRow][rookFromCol] = null;
            }

            boardState[toRow][toCol] = piece;
            boardState[fromRow][fromCol] = null;

            if (piece.type.toLowerCase() === 'p' && Math.abs(fromRow - toRow) === 2) {
                const targetRow = 8 - ((fromRow + toRow) / 2);
                const targetCol = String.fromCharCode('a'.charCodeAt(0) + fromCol);
                newEnPassantTarget = `${targetCol}${targetRow}`;
            }
            enPassantTarget = newEnPassantTarget;
            
            updateCastlingRights(fromRow, fromCol, piece);
            const prevPlayer = currentPlayer;
            currentPlayer = currentPlayer === 'w' ? 'b' : 'w';
            
            const newFen = generateFen();
            const gameRef = doc(db, `/artifacts/${appId}/public/data/games`, currentGameId);

            // Update time with increment
            let updatedTimeData = {};
            if (prevPlayer === 'w') {
                localTimeW += timerSettings.increment * 1000;
                updatedTimeData.timeW = localTimeW;
            } else {
                localTimeB += timerSettings.increment * 1000;
                updatedTimeData.timeB = localTimeB;
            }

            await updateDoc(gameRef, { 
                fen: newFen, 
                ...updatedTimeData,
                lastMoveTimestamp: serverTimestamp()
            });
            
            await checkGameOver();
        }
        
        function updateCastlingRights(fromRow, fromCol, movedPiece) {
            if (movedPiece.type === 'K') {
                castlingRights = castlingRights.replace('K', '').replace('Q', '');
            } else if (movedPiece.type === 'k') {
                castlingRights = castlingRights.replace('k', '').replace('q', '');
            } else if (movedPiece.type === 'R') {
                if (fromRow === 7 && fromCol === 0) castlingRights = castlingRights.replace('Q', '');
                if (fromRow === 7 && fromCol === 7) castlingRights = castlingRights.replace('K', '');
            } else if (movedPiece.type === 'r') {
                if (fromRow === 0 && fromCol === 0) castlingRights = castlingRights.replace('q', '');
                if (fromRow === 0 && fromCol === 7) castlingRights = castlingRights.replace('k', '');
            }
            if (castlingRights === '') castlingRights = '-';
        }

        function showPromotionModal(color) {
            const modal = document.getElementById('promotionModal');
            const choicesDiv = document.getElementById('promotionChoices');
            choicesDiv.innerHTML = '';
            const pieces = color === 'w' ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];
            pieces.forEach(p => {
                const img = document.createElement('img');
                img.src = imageBaseUrl + pieceImageMap[p];
                img.classList.add('piece', 'cursor-pointer', 'rounded-md', 'p-2', 'promotion-choice');
                img.style.width = '80px';
                img.style.height = '80px';
                img.onclick = () => promotePawn(p);
                choicesDiv.appendChild(img);
            });
            modal.classList.remove('hidden');
        }

        function promotePawn(pieceType) {
            const { fromRow, fromCol, toRow, toCol } = promotionMoveInfo;
            performMove(fromRow, fromCol, toRow, toCol, pieceType);
            document.getElementById('promotionModal').classList.add('hidden');
            promotionMoveInfo = null;
        }

        function showValidMoves(square) {
            clearValidMoves();
            const fromRow = parseInt(square.dataset.row);
            const fromCol = parseInt(square.dataset.col);
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(fromRow, fromCol, r, c)) {
                        const targetSquare = boardElement.querySelector(`[data-row='${r}'][data-col='${c}']`);
                        targetSquare.classList.add('valid-move');
                    }
                }
            }
        }
        
        function clearValidMoves() {
            document.querySelectorAll('.valid-move').forEach(sq => sq.classList.remove('valid-move'));
        }

        // --- Timer Logic ---
        function formatTime(ms) {
            if (ms <= 0) return "00:00";
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
            const seconds = (totalSeconds % 60).toString().padStart(2, '0');
            return `${minutes}:${seconds}`;
        }

        function updateTimers(gameData) {
            stopTimer();
            if (isGameOver) {
                timeWDisplay.textContent = formatTime(gameData.timeW);
                timeBDisplay.textContent = formatTime(gameData.timeB);
                return;
            };

            // If waiting for a player, display initial time but don't start clock.
            if (!areTwoPlayers) {
                const initialTime = gameData.timeControl.minutes * 60 * 1000;
                timeWDisplay.textContent = formatTime(initialTime);
                timeBDisplay.textContent = formatTime(initialTime);
                document.getElementById('timer-w').classList.remove('active');
                document.getElementById('timer-b').classList.remove('active');
                return;
            }

            localTimeW = gameData.timeW;
            localTimeB = gameData.timeB;

            const timeSinceLastMove = gameData.lastMoveTimestamp ? Date.now() - gameData.lastMoveTimestamp.toDate().getTime() : 0;
            
            if (currentPlayer === 'w') {
                localTimeW -= timeSinceLastMove;
            } else {
                localTimeB -= timeSinceLastMove;
            }
            
            timeWDisplay.textContent = formatTime(localTimeW);
            timeBDisplay.textContent = formatTime(localTimeB);

            document.getElementById('timer-w').classList.toggle('active', currentPlayer === 'w');
            document.getElementById('timer-b').classList.toggle('active', currentPlayer === 'b');
            
            startTimer();
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (isGameOver) {
                    stopTimer();
                    return;
                }
                const timeToUpdate = currentPlayer === 'w' ? 'localTimeW' : 'localTimeB';
                if (timeToUpdate === 'localTimeW') {
                    localTimeW -= 1000;
                    timeWDisplay.textContent = formatTime(localTimeW);
                    if (localTimeW <= 0) handleTimeout();
                } else {
                    localTimeB -= 1000;
                    timeBDisplay.textContent = formatTime(localTimeB);
                    if (localTimeB <= 0) handleTimeout();
                }
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        async function handleTimeout() {
            stopTimer();
            if (playerColor === currentPlayer && !isGameOver) {
                const winner = playerColor === 'w' ? 'b' : 'w';
                await updateGameWithResult(winner, "Timeout");
            }
        }

        // --- Game Over Logic ---

        function generateAllValidMoves(color, board) {
            const moves = [];
            for (let r1 = 0; r1 < 8; r1++) {
                for (let c1 = 0; c1 < 8; c1++) {
                    const piece = board[r1][c1];
                    if (piece && piece.color === color) {
                        for (let r2 = 0; r2 < 8; r2++) {
                            for (let c2 = 0; c2 < 8; c2++) {
                                if (isValidMove(r1, c1, r2, c2)) {
                                    moves.push({ from: {r:r1, c:c1}, to: {r:r2, c:c2} });
                                }
                            }
                        }
                    }
                }
            }
            return moves;
        }

        async function checkGameOver() {
            const possibleMoves = generateAllValidMoves(currentPlayer, boardState);
            if (possibleMoves.length > 0) return;

            const opponentColor = currentPlayer === 'w' ? 'b' : 'w';

            if (isKingInCheck(currentPlayer, boardState)) {
                await updateGameWithResult(opponentColor, "Checkmate");
            } else {
                await updateGameWithResult('draw', "Stalemate");
            }
        }
        
        function showEndGameModal(result, reason) {
            endGameResultText.textContent = result;
            endGameReasonText.textContent = reason;
            playAgainBtn.disabled = false;
            playAgainBtn.textContent = "Play Again";
            endGameModal.classList.remove('hidden');
        }

        async function updateGameWithResult(winner, reason) {
            if (!currentGameId || isGameOver) return;
            isGameOver = true;
            const gameRef = doc(db, `/artifacts/${appId}/public/data/games`, currentGameId);
            await updateDoc(gameRef, { winner: winner, reason: reason });
        }

        async function requestRematch() {
            if (!currentGameId || !playerColor) return;

            playAgainBtn.disabled = true;
            playAgainBtn.textContent = "Waiting for Opponent...";

            const gameRef = doc(db, `/artifacts/${appId}/public/data/games`, currentGameId);
            
            const updateData = {};
            if (playerColor === 'w') {
                updateData['rematch.w'] = true;
            } else {
                updateData['rematch.b'] = true;
            }
            await updateDoc(gameRef, updateData);
        }


        // --- Move Validation Logic (Unchanged) ---
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            const piece = boardState[fromRow][fromCol];
            if (!piece || (fromRow === toRow && fromCol === toCol)) return false;
            const targetPiece = boardState[toRow][toCol];
            if (targetPiece && targetPiece.color === piece.color) return false;

            if (!isValidMoveForPieceType(fromRow, fromCol, toRow, toCol, piece, boardState)) {
                return false;
            }

            const tempBoard = JSON.parse(JSON.stringify(boardState));
            tempBoard[toRow][toCol] = tempBoard[fromRow][fromCol];
            tempBoard[fromRow][fromCol] = null;
            if (isKingInCheck(piece.color, tempBoard)) {
                return false;
            }
            return true;
        }

        function isValidMoveForPieceType(r1, c1, r2, c2, piece, board) {
            switch (piece.type.toLowerCase()) {
                case 'p': return isValidPawnMove(r1, c1, r2, c2, piece.color, board);
                case 'r': return isValidRookMove(r1, c1, r2, c2, board);
                case 'n': return isValidKnightMove(r1, c1, r2, c2, board);
                case 'b': return isValidBishopMove(r1, c1, r2, c2, board);
                case 'q': return isValidQueenMove(r1, c1, r2, c2, board);
                case 'k': return isValidKingMove(r1, c1, r2, c2, piece.color, board);
            }
            return false;
        }

        function isValidPawnMove(r1, c1, r2, c2, color, board, isAttackCheck = false) {
            const dir = color === 'w' ? -1 : 1;
            if (isAttackCheck) return r1 + dir === r2 && Math.abs(c1 - c2) === 1;

            const startRow = color === 'w' ? 6 : 1;
            const target = board[r2][c2];
            // Standard 1 or 2 square move forward
            if (c1 === c2 && !target) {
                if (r1 + dir === r2) return true;
                if (r1 === startRow && r1 + 2 * dir === r2 && !board[r1 + dir][c1]) return true;
            }
            // Standard capture
            if (Math.abs(c1 - c2) === 1 && r1 + dir === r2 && target) return true;
            
            // En passant capture
            if (enPassantTarget !== '-') {
                const targetCol = enPassantTarget.charCodeAt(0) - 'a'.charCodeAt(0);
                const targetRow = 8 - parseInt(enPassantTarget[1]);
                if (r2 === targetRow && c2 === targetCol && !target) {
                    if (Math.abs(c1 - c2) === 1 && r1 + dir === r2) {
                        return true;
                    }
                }
            }
            return false;
        }

        function isValidRookMove(r1, c1, r2, c2, board) {
            if (r1 !== r2 && c1 !== c2) return false;
            return isPathClear(r1, c1, r2, c2, board);
        }

        function isValidBishopMove(r1, c1, r2, c2, board) {
            if (Math.abs(r1 - r2) !== Math.abs(c1 - c2)) return false;
            return isPathClear(r1, c1, r2, c2, board);
        }

        function isValidQueenMove(r1, c1, r2, c2, board) {
            return isValidRookMove(r1, c1, r2, c2, board) || isValidBishopMove(r1, c1, r2, c2, board);
        }

        function isValidKnightMove(r1, c1, r2, c2, board) {
            const dr = Math.abs(r1 - r2); const dc = Math.abs(c1 - c2);
            return (dr === 2 && dc === 1) || (dr === 1 && dc === 2);
        }

        function isValidKingMove(r1, c1, r2, c2, color, board) {
            const dr = Math.abs(r1 - r2); const dc = Math.abs(c1 - c2);
            if (dr <= 1 && dc <= 1) return true;

            // Castling
            if (dr === 0 && dc === 2) {
                if (isKingInCheck(color, board)) return false;
                const opponentColor = color === 'w' ? 'b' : 'w';
                if (c2 > c1) { // Kingside
                    const canCastle = color === 'w' ? castlingRights.includes('K') : castlingRights.includes('k');
                    if (!canCastle || board[r1][c1+1] || board[r1][c1+2]) return false;
                    if (isSquareAttacked(r1, c1+1, opponentColor, board) || isSquareAttacked(r1, c1+2, opponentColor, board)) return false;
                    return true;
                } else { // Queenside
                    const canCastle = color === 'w' ? castlingRights.includes('Q') : castlingRights.includes('q');
                    if (!canCastle || board[r1][c1-1] || board[r1][c1-2] || board[r1][c1-3]) return false;
                    if (isSquareAttacked(r1, c1-1, opponentColor, board) || isSquareAttacked(r1, c1-2, opponentColor, board)) return false;
                    return true;
                }
            }
            return false;
        }

        function isPathClear(r1, c1, r2, c2, board) {
            const dr = Math.sign(r2 - r1); const dc = Math.sign(c2 - c1);
            let r = r1 + dr; let c = c1 + dc;
            while (r !== r2 || c !== c2) {
                if (board[r][c]) return false;
                r += dr; c += dc;
            }
            return true;
        }
        
        function findKing(color, board) {
            const kingType = color === 'w' ? 'K' : 'k';
            for (let r = 0; r < 8; r++) {
                if (board[r]) { // Fix: Ensure row exists before accessing it
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] && board[r][c].type === kingType) return { row: r, col: c };
                    }
                }
            }
            return null;
        }

        function isKingInCheck(kingColor, board) {
            const kingPos = findKing(kingColor, board);
            if (!kingPos) return true; // Should not happen in a real game
            return isSquareAttacked(kingPos.row, kingPos.col, kingColor === 'w' ? 'b' : 'w', board);
        }

        function isSquareAttacked(row, col, attackerColor, board) {
            for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
                const piece = board[r][c];
                if (piece && piece.color === attackerColor) {
                    if (piece.type.toLowerCase() === 'p') {
                        if (isValidPawnMove(r, c, row, col, piece.color, board, true)) return true;
                    } else if (isValidMoveForPieceType(r, c, row, col, piece, board)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // --- Initial Setup ---
        createGameBtn.addEventListener('click', createGame);
        joinGameBtn.addEventListener('click', () => joinGame(gameIdInput.value.trim().toUpperCase()));
        playAgainBtn.addEventListener('click', requestRematch);
        
        gameIdDisplay.addEventListener('click', () => {
            copyTextToClipboard(currentGameId);
        });

        copyFenBtn.addEventListener('click', () => {
            copyTextToClipboard(fenInputElement.value);
        });

        async function init() {
            createBoard();
            parseFen(initialFen);
            boardElement.addEventListener('mousedown', onDragStart);
            await signIn();
        }

        init();
    </script>
</body>
</html>

